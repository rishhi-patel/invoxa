pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Select Terraform action to perform'
        )
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Auto-approve Terraform apply (use with caution)'
        )
        booleanParam(
            name: 'DEPLOY_CONTAINERS',
            defaultValue: true,
            description: 'Build and deploy container images to ECS'
        )
        string(
            name: 'DEPLOYMENT_TICKET',
            defaultValue: '',
            description: 'Deployment ticket number (required for production deployments)'
        )
    }
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        ENVIRONMENT = 'dev'
        TF_VAR_prefix = 'INX-DEV-USNV-'
        ECR_REPOSITORY = 'inx-INX-DEV-USNV--app'
        ECS_CLUSTER = 'INX-DEV-USNV-CLUSTER01'
        
        // Terraform backend configuration
        TF_STATE_BUCKET = 'inx-dev-terraform-state-9015480'
        TF_STATE_KEY = 'terraform.tfstate'
        TF_LOCK_TABLE = 'inx-dev-tf-locks'
        
        // AWS Role for DEV environment
        AWS_ROLE_ARN = 'arn:aws:iam::857736875915:role/RINX_DEVAWS_JENKINS_ADM'
    }
    
    stages {
        stage('ðŸ” Environment Validation') {
            steps {
                script {
                    echo "ðŸš€ Starting INVOXA Infrastructure Deployment - DEV Environment"
                    echo "Branch: ${env.BRANCH_NAME}"
                    echo "Environment: ${env.ENVIRONMENT}"
                    echo "Action: ${params.ACTION}"
                    
                    if (env.BRANCH_NAME != 'cicd') {
                        error "âŒ DEV pipeline should only run on 'cicd' branch. Current branch: ${env.BRANCH_NAME}"
                    }
                }
            }
        }
        
        stage('ðŸ” AWS Authentication') {
            steps {
                script {
                    echo "ðŸ” Assuming AWS Role for DEV environment..."
                    
                    withCredentials([aws(credentialsId: 'aws-jenkins-credentials', region: env.AWS_DEFAULT_REGION)]) {
                        def assumeRoleResult = sh(
                            script: """
                                aws sts assume-role \
                                    --role-arn ${env.AWS_ROLE_ARN} \
                                    --role-session-name jenkins-dev-session-\${BUILD_NUMBER} \
                                    --duration-seconds 3600 \
                                    --output json
                            """,
                            returnStdout: true
                        ).trim()
                        
                        def credentials = readJSON text: assumeRoleResult
                        
                        env.AWS_ACCESS_KEY_ID = credentials.Credentials.AccessKeyId
                        env.AWS_SECRET_ACCESS_KEY = credentials.Credentials.SecretAccessKey
                        env.AWS_SESSION_TOKEN = credentials.Credentials.SessionToken
                        
                        echo "âœ… AWS credentials configured successfully"
                    }
                }
            }
        }
        
        stage('ðŸ“‹ Infrastructure Analysis') {
            steps {
                dir('terraform') {
                    script {
                        echo "ðŸ“‹ Analyzing Terraform configuration..."
                        
                        // Initialize Terraform
                        sh """
                            terraform init \
                                -backend-config="bucket=${env.TF_STATE_BUCKET}" \
                                -backend-config="key=${env.TF_STATE_KEY}" \
                                -backend-config="region=${env.AWS_DEFAULT_REGION}" \
                                -backend-config="dynamodb_table=${env.TF_LOCK_TABLE}" \
                                -reconfigure
                        """
                        
                        // Generate plan
                        def planOutput = sh(
                            script: 'terraform plan -var-file=dev.tfvars -detailed-exitcode -no-color',
                            returnStatus: true
                        )
                        
                        env.PLAN_EXIT_CODE = planOutput.toString()
                        
                        if (planOutput == 0) {
                            echo "âœ… No infrastructure changes detected"
                            env.HAS_CHANGES = 'false'
                        } else if (planOutput == 2) {
                            echo "ðŸ“Š Infrastructure changes detected - generating detailed plan..."
                            sh 'terraform plan -var-file=dev.tfvars -out=tfplan-dev'
                            
                            // Show what will change
                            def planShow = sh(
                                script: 'terraform show -no-color tfplan-dev',
                                returnStdout: true
                            )
                            
                            echo "ðŸ”„ PLANNED CHANGES:"
                            echo planShow
                            env.HAS_CHANGES = 'true'
                        } else {
                            error "âŒ Terraform plan failed with exit code: ${planOutput}"
                        }
                    }
                }
            }
        }
        
        stage('ðŸ—ï¸ Infrastructure Deployment') {
            when {
                anyOf {
                    expression { params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
                    expression { params.ACTION == 'destroy' }
                }
            }
            steps {
                dir('terraform') {
                    script {
                        if (params.ACTION == 'apply') {
                            echo "ðŸ—ï¸ Deploying infrastructure changes..."
                            
                            if (params.AUTO_APPROVE) {
                                sh 'terraform apply -auto-approve tfplan-dev'
                            } else {
                                timeout(time: 10, unit: 'MINUTES') {
                                    input message: 'Approve infrastructure deployment?', ok: 'Deploy'
                                }
                                sh 'terraform apply -auto-approve tfplan-dev'
                            }
                            
                            echo "âœ… Infrastructure deployment completed successfully!"
                            
                            // Store outputs for later stages
                            def outputs = sh(
                                script: 'terraform output -json',
                                returnStdout: true
                            )
                            writeFile file: 'terraform-outputs.json', text: outputs
                            archiveArtifacts artifacts: 'terraform-outputs.json'
                            
                        } else if (params.ACTION == 'destroy') {
                            echo "ðŸ—‘ï¸ Destroying infrastructure..."
                            timeout(time: 5, unit: 'MINUTES') {
                                input message: 'Are you sure you want to DESTROY the infrastructure?', ok: 'Destroy'
                            }
                            sh 'terraform destroy -var-file=dev.tfvars -auto-approve'
                        }
                    }
                }
            }
        }
        
        stage('ðŸ³ Container Build & Push') {
            when {
                expression { params.DEPLOY_CONTAINERS && (params.ACTION == 'apply' || params.ACTION == 'plan') }
            }
            parallel {
                stage('Auth Service') {
                    steps {
                        script {
                            buildAndPushImage('auth-service', 'microservices/auth-service')
                        }
                    }
                }
                stage('Client Service') {
                    steps {
                        script {
                            buildAndPushImage('client-service', 'microservices/client-service')
                        }
                    }
                }
                stage('Invoice Service') {
                    steps {
                        script {
                            buildAndPushImage('invoice-service', 'microservices/invoice-service')
                        }
                    }
                }
                stage('Notification Service') {
                    steps {
                        script {
                            buildAndPushImage('notification-service', 'microservices/notification-service')
                        }
                    }
                }
                stage('Payment Service') {
                    steps {
                        script {
                            buildAndPushImage('payment-service', 'microservices/payment-service')
                        }
                    }
                }
            }
        }
        
        stage('ðŸš€ ECS Service Deployment') {
            when {
                expression { params.DEPLOY_CONTAINERS && params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
            }
            steps {
                script {
                    echo "ðŸš€ Deploying services to ECS Fargate..."
                    
                    def services = ['auth-service', 'client-service', 'invoice-service', 'notification-service', 'payment-service']
                    
                    services.each { service ->
                        deployECSService(service)
                    }
                }
            }
        }
        
        stage('âœ… Deployment Verification') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                script {
                    if (env.HAS_CHANGES == 'false') {
                        echo """
                        âœ… DEPLOYMENT STATUS: NO CHANGES REQUIRED
                        
                        ðŸ“Š Infrastructure State: Up to date
                        ðŸ—ï¸ Resources: All resources match desired configuration
                        ðŸ“… Last Updated: Current state is already aligned with Terraform configuration
                        
                        ðŸ’¡ Summary: No infrastructure changes were detected. Your DEV environment is running the latest configuration.
                        """
                    } else {
                        echo """
                        âœ… DEPLOYMENT STATUS: SUCCESSFULLY COMPLETED
                        
                        ðŸ—ï¸ Infrastructure: Updated with latest changes
                        ðŸ³ Containers: Built and pushed to ECR
                        ðŸš€ Services: Deployed to ECS Fargate
                        ðŸ“… Deployment Time: ${new Date()}
                        ðŸŽ« Ticket: ${params.DEPLOYMENT_TICKET ?: 'N/A'}
                        
                        ðŸ’¡ Summary: All components have been successfully deployed to the DEV environment.
                        """
                        
                        // Get ALB DNS name for verification
                        dir('terraform') {
                            def albDns = sh(
                                script: 'terraform output -raw alb_dns_name 2>/dev/null || echo "Not available"',
                                returnStdout: true
                            ).trim()
                            
                            if (albDns && albDns != "Not available") {
                                echo "ðŸŒ Application URL: http://${albDns}"
                            }
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up
                sh 'rm -f terraform/tfplan-dev terraform/terraform-outputs.json'
                
                // Clear AWS credentials
                env.AWS_ACCESS_KEY_ID = ''
                env.AWS_SECRET_ACCESS_KEY = ''
                env.AWS_SESSION_TOKEN = ''
            }
        }
        success {
            echo 'âœ… Pipeline completed successfully!'
        }
        failure {
            echo 'âŒ Pipeline failed - check logs for details'
        }
        cleanup {
            cleanWs()
        }
    }
}

// Helper function to build and push Docker images
def buildAndPushImage(serviceName, contextPath) {
    echo "ðŸ³ Building ${serviceName}..."
    
    // Get ECR login token
    sh '''
        aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
        docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com
    '''
    
    // Build image
    def imageTag = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}"
    def fullImageName = "${env.ECR_REPOSITORY}:${serviceName}-${imageTag}"
    
    dir(contextPath) {
        sh """
            docker build -t ${serviceName}:latest .
            docker tag ${serviceName}:latest ${fullImageName}
            docker tag ${serviceName}:latest ${env.ECR_REPOSITORY}:${serviceName}-latest
        """
    }
    
    // Push to ECR
    sh """
        docker push ${fullImageName}
        docker push ${env.ECR_REPOSITORY}:${serviceName}-latest
    """
    
    echo "âœ… ${serviceName} image pushed successfully"
}

// Helper function to deploy ECS services
def deployECSService(serviceName) {
    echo "ðŸš€ Deploying ${serviceName} to ECS..."
    
    // Check if service exists
    def serviceExists = sh(
        script: """
            aws ecs describe-services \
                --cluster ${env.ECS_CLUSTER} \
                --services ${env.TF_VAR_prefix}${serviceName} \
                --region ${env.AWS_DEFAULT_REGION} \
                --query 'services[0].status' \
                --output text 2>/dev/null || echo 'NONE'
        """,
        returnStdout: true
    ).trim()
    
    if (serviceExists == 'NONE' || serviceExists == 'INACTIVE') {
        echo "Creating new ECS service for ${serviceName}..."
        // Create service logic here
        sh """
            aws ecs create-service \
                --cluster ${env.ECS_CLUSTER} \
                --service-name ${env.TF_VAR_prefix}${serviceName} \
                --task-definition ${env.TF_VAR_prefix}${serviceName} \
                --desired-count 1 \
                --launch-type FARGATE \
                --network-configuration 'awsvpcConfiguration={subnets=[subnet-xxx],securityGroups=[sg-xxx],assignPublicIp=DISABLED}' \
                --region ${env.AWS_DEFAULT_REGION}
        """
    } else {
        echo "Updating existing ECS service for ${serviceName}..."
        sh """
            aws ecs update-service \
                --cluster ${env.ECS_CLUSTER} \
                --service ${env.TF_VAR_prefix}${serviceName} \
                --task-definition ${env.TF_VAR_prefix}${serviceName} \
                --region ${env.AWS_DEFAULT_REGION}
        """
    }
    
    echo "âœ… ${serviceName} deployment initiated"
}
