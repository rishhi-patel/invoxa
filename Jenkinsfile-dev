pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Select Terraform action to perform'
        )
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Auto-approve Terraform apply (use with caution)'
        )
        booleanParam(
            name: 'DEPLOY_CONTAINERS',
            defaultValue: true,
            description: 'Build and deploy container images to ECS'
        )
        string(
            name: 'DEPLOYMENT_TICKET',
            defaultValue: '',
            description: 'Deployment ticket number (required for production deployments)'
        )
    }
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '857736875915'  // Add your AWS account ID
        ENVIRONMENT = 'dev'
        TF_VAR_prefix = 'INX-DEV-USNV-'
        ECR_REPOSITORY_BASE = 'public.ecr.aws/your-alias/inx-INX-DEV-USNV--app'
        ECS_CLUSTER = 'INX-DEV-USNV-CLUSTER01'
        
        // Terraform backend configuration
        TF_STATE_BUCKET = 'inx-dev-terraform-state'
        TF_STATE_KEY = 'terraform.tfstate'
        TF_LOCK_TABLE = 'inx-dev-tf-locks'
        
        // AWS Role for DEV environment
        AWS_ROLE_ARN = 'arn:aws:iam::857736875915:role/RINX_DEVAWS_JENKINS_ADM'
    }
    
    stages {
        stage('üîç Environment Validation') {
            steps {
                script {
                    echo "üöÄ Starting INVOXA Infrastructure Deployment - DEV Environment"
                    
                    // Get branch name from Git
                    def branchName = env.BRANCH_NAME ?: sh(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                    
                    echo "Branch: ${branchName}"
                    echo "Environment: ${env.ENVIRONMENT}"
                    echo "Action: ${params.ACTION}"
                    echo "Git Commit: ${env.GIT_COMMIT ?: 'Not available'}"
                    
                    // Store branch name for other stages
                    env.CURRENT_BRANCH = branchName
                    
                    // Branch validation (relaxed for initial testing)
                    if (branchName != 'cicd') {
                        echo "‚ö†Ô∏è Warning: DEV pipeline is recommended to run on 'cicd' branch. Current branch: ${branchName}"
                        echo "‚ÑπÔ∏è Continuing deployment for testing purposes..."
                        // For initial testing, we'll continue instead of failing
                        // Uncomment the line below to enforce branch restriction:
                        // error "‚ùå DEV pipeline should only run on 'cicd' branch. Current branch: ${branchName}"
                    } else {
                        echo "‚úÖ Running on correct branch: ${branchName}"
                    }
                }
            }
        }
        
        stage('üîê AWS Authentication') {
            steps {
                script {
                    echo "ÔøΩ Installing/Updating AWS CLI..."
                    
                    // Install AWS CLI v2 if not present or update if outdated
                    sh '''
                        # Check if AWS CLI is installed
                        if ! command -v aws &> /dev/null; then
                            echo "üì• Installing AWS CLI v2..."
                            apt-get update -y
                            apt-get install -y curl unzip
                            curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
                            unzip awscliv2.zip
                            sudo ./aws/install
                            rm -rf awscliv2.zip aws/
                        else
                            echo "‚úÖ AWS CLI already installed"
                        fi
                        
                        # Verify installation
                        aws --version
                    '''
                    
                    echo "üîê Using AWS credentials for DEV environment..."
                    
                    withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
                        // Test AWS access
                        def callerIdentity = sh(
                            script: 'aws sts get-caller-identity --output json',
                            returnStdout: true
                        ).trim()
                        
                        def identity = readJSON text: callerIdentity
                        echo "‚úÖ AWS authenticated as: ${identity.Arn}"
                        echo "‚úÖ Account ID: ${identity.Account}"
                        
                        // Verify access to S3 bucket
                        sh "aws s3 ls s3://${env.TF_STATE_BUCKET}/ || echo 'Note: S3 bucket may not exist yet - will be created if needed'"
                    }
                }
            }
        }
        
        stage('üìã Infrastructure Analysis') {
            steps {
                dir('terraform') {
                    script {
                        echo "üìã Analyzing Terraform configuration..."
                        
                        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
                            // Initialize Terraform
                            sh """
                                terraform init \
                                    -backend-config="bucket=${env.TF_STATE_BUCKET}" \
                                    -backend-config="key=${env.TF_STATE_KEY}" \
                                    -backend-config="region=${env.AWS_DEFAULT_REGION}" \
                                    -backend-config="dynamodb_table=${env.TF_LOCK_TABLE}" \
                                    -reconfigure
                            """
                            
                            // Generate plan
                            def planOutput = sh(
                                script: 'terraform plan -var-file=dev.tfvars -detailed-exitcode -no-color',
                                returnStatus: true
                            )
                            
                            env.PLAN_EXIT_CODE = planOutput.toString()
                            
                            if (planOutput == 0) {
                                echo "‚úÖ No infrastructure changes detected"
                                env.HAS_CHANGES = 'false'
                            } else if (planOutput == 2) {
                                echo "üìä Infrastructure changes detected - generating detailed plan..."
                                sh 'terraform plan -var-file=dev.tfvars -out=tfplan-dev'
                                
                                // Show what will change
                                def planShow = sh(
                                    script: 'terraform show -no-color tfplan-dev',
                                    returnStdout: true
                                )
                                
                                echo "üîÑ PLANNED CHANGES:"
                                echo planShow
                                env.HAS_CHANGES = 'true'
                            } else {
                                error "‚ùå Terraform plan failed with exit code: ${planOutput}"
                            }
                        }
                    }
                }
            }
        }
        
        stage('üèóÔ∏è Infrastructure Deployment') {
            when {
                anyOf {
                    expression { params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
                    expression { params.ACTION == 'destroy' }
                }
            }
            steps {
                dir('terraform') {
                    script {
                        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
                            if (params.ACTION == 'apply') {
                                echo "üèóÔ∏è Deploying infrastructure changes..."
                                
                                if (params.AUTO_APPROVE) {
                                    sh 'terraform apply -auto-approve tfplan-dev'
                                } else {
                                    timeout(time: 10, unit: 'MINUTES') {
                                        input message: 'Approve infrastructure deployment?', ok: 'Deploy'
                                    }
                                    sh 'terraform apply -auto-approve tfplan-dev'
                                }
                                
                                echo "‚úÖ Infrastructure deployment completed successfully!"
                                
                                // Store outputs for later stages
                                def outputs = sh(
                                    script: 'terraform output -json',
                                    returnStdout: true
                                )
                                writeFile file: 'terraform-outputs-dev.json', text: outputs
                                archiveArtifacts artifacts: 'terraform-outputs-dev.json'
                                
                            } else if (params.ACTION == 'destroy') {
                                echo "üóëÔ∏è Destroying infrastructure..."
                                timeout(time: 5, unit: 'MINUTES') {
                                    input message: 'Are you sure you want to DESTROY the infrastructure?', ok: 'Destroy'
                                }
                                sh 'terraform destroy -var-file=dev.tfvars -auto-approve'
                            }
                        }
                    }
                }
            }
        }
        
        stage('üê≥ Container Build & Push') {
            when {
                expression { params.DEPLOY_CONTAINERS && (params.ACTION == 'apply' || params.ACTION == 'plan') }
            }
            parallel {
                stage('Auth Service') {
                    steps {
                        script {
                            buildAndPushImage('auth-service', 'microservices/auth-service')
                        }
                    }
                }
                stage('Client Service') {
                    steps {
                        script {
                            buildAndPushImage('client-service', 'microservices/client-service')
                        }
                    }
                }
                stage('Invoice Service') {
                    steps {
                        script {
                            buildAndPushImage('invoice-service', 'microservices/invoice-service')
                        }
                    }
                }
                stage('Notification Service') {
                    steps {
                        script {
                            buildAndPushImage('notification-service', 'microservices/notification-service')
                        }
                    }
                }
                stage('Payment Service') {
                    steps {
                        script {
                            buildAndPushImage('payment-service', 'microservices/payment-service')
                        }
                    }
                }
            }
        }
        
        stage('üöÄ ECS Service Deployment') {
            when {
                expression { params.DEPLOY_CONTAINERS && params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
            }
            steps {
                script {
                    echo "üöÄ Deploying services to ECS Fargate..."
                    
                    def services = ['auth-service', 'client-service', 'invoice-service', 'notification-service', 'payment-service']
                    
                    services.each { service ->
                        deployECSService(service)
                    }
                }
            }
        }
        
        stage('‚úÖ Deployment Verification') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                script {
                    if (env.HAS_CHANGES == 'false') {
                        echo """
                        ‚úÖ DEPLOYMENT STATUS: NO CHANGES REQUIRED
                        
                        üìä Infrastructure State: Up to date
                        üèóÔ∏è Resources: All resources match desired configuration
                        üìÖ Last Updated: Current state is already aligned with Terraform configuration
                        
                        üí° Summary: No infrastructure changes were detected. Your DEV environment is running the latest configuration.
                        """
                    } else {
                        echo """
                        ‚úÖ DEPLOYMENT STATUS: SUCCESSFULLY COMPLETED
                        
                        üèóÔ∏è Infrastructure: Updated with latest changes
                        üê≥ Containers: Built and pushed to ECR
                        üöÄ Services: Deployed to ECS Fargate
                        üìÖ Deployment Time: ${new Date()}
                        üé´ Ticket: ${params.DEPLOYMENT_TICKET ?: 'N/A'}
                        
                        üí° Summary: All components have been successfully deployed to the DEV environment.
                        """
                        
                        // Get ALB DNS name for verification
                        dir('terraform') {
                            def albDns = sh(
                                script: 'terraform output -raw alb_dns_name 2>/dev/null || echo "Not available"',
                                returnStdout: true
                            ).trim()
                            
                            if (albDns && albDns != "Not available") {
                                echo "üåê Application URL: http://${albDns}"
                            }
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up
                sh 'rm -f terraform/tfplan-dev terraform/terraform-outputs-dev.json'
                
                // Clear AWS credentials
                env.AWS_ACCESS_KEY_ID = ''
                env.AWS_SECRET_ACCESS_KEY = ''
                env.AWS_SESSION_TOKEN = ''
            }
        }
        success {
            echo '‚úÖ Pipeline completed successfully!'
        }
        failure {
            echo '‚ùå Pipeline failed - check logs for details'
        }
        cleanup {
            cleanWs()
        }
    }
}

// Helper function to build and push Docker images
def buildAndPushImage(serviceName, contextPath) {
    echo "üê≥ Building ${serviceName}..."
    
    try {
        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
            // Get Public ECR login token (us-east-1 only)
            sh '''
                aws ecr-public get-login-password --region us-east-1 | \
                docker login --username AWS --password-stdin public.ecr.aws
            '''
            
            // Build image
            def imageTag = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}"
            def fullImageName = "${env.ECR_REPOSITORY_BASE}:${serviceName}-${imageTag}"
            
            dir(contextPath) {
                sh """
                    docker build -t ${serviceName}:latest .
                    docker tag ${serviceName}:latest ${fullImageName}
                    docker tag ${serviceName}:latest ${env.ECR_REPOSITORY_BASE}:${serviceName}-latest
                """
            }
            
            // Push to Public ECR
            sh """
                docker push ${fullImageName}
                docker push ${env.ECR_REPOSITORY_BASE}:${serviceName}-latest
            """
            
            echo "‚úÖ ${serviceName} image pushed successfully to Public ECR"
        }
        
    } catch (Exception e) {
        error "‚ùå Failed to build/push ${serviceName}: ${e.getMessage()}"
    }
}

// Helper function to deploy ECS services
def deployECSService(serviceName) {
    echo "üöÄ Deploying ${serviceName} to ECS..."
    
    try {
        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
            // Get network configuration from Terraform outputs  
            def terraformOutputs = readJSON file: 'terraform/terraform-outputs-dev.json'
            def privateSubnets = terraformOutputs.private_subnet_ids.value.join(',')
            def securityGroupId = terraformOutputs.ecs_security_group_id.value
            
            // Check if service exists
            def serviceExists = sh(
                script: """
                    aws ecs describe-services \
                        --cluster ${env.ECS_CLUSTER} \
                        --services ${env.TF_VAR_prefix}${serviceName} \
                        --region ${env.AWS_DEFAULT_REGION} \
                        --query 'services[0].status' \
                        --output text 2>/dev/null || echo 'NONE'
                """,
                returnStdout: true
            ).trim()
            
            if (serviceExists == 'NONE' || serviceExists == 'INACTIVE') {
                echo "Creating new ECS service for ${serviceName}..."
                // Create service logic here
                sh """
                    aws ecs create-service \
                        --cluster ${env.ECS_CLUSTER} \
                        --service-name ${env.TF_VAR_prefix}${serviceName} \
                        --task-definition ${env.TF_VAR_prefix}${serviceName} \
                        --desired-count 1 \
                        --launch-type FARGATE \
                        --network-configuration 'awsvpcConfiguration={subnets=[${privateSubnets}],securityGroups=[${securityGroupId}],assignPublicIp=DISABLED}' \
                        --region ${env.AWS_DEFAULT_REGION}
                """
            } else {
                echo "Updating existing ECS service for ${serviceName}..."
                sh """
                    aws ecs update-service \
                        --cluster ${env.ECS_CLUSTER} \
                        --service ${env.TF_VAR_prefix}${serviceName} \
                        --task-definition ${env.TF_VAR_prefix}${serviceName} \
                        --region ${env.AWS_DEFAULT_REGION}
                """
            }
            
            echo "‚úÖ ${serviceName} deployment initiated"
        }
        
    } catch (Exception e) {
        error "‚ùå Failed to deploy ${serviceName} to ECS: ${e.getMessage()}"
    }
}
