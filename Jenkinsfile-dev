pipeline {
	agent any

	options {
		timestamps()
		disableConcurrentBuilds()
	}

	environment {
		ENVIRONMENT = 'dev'
		AWS_REGION = 'eu-west-1'
		AWS_CREDENTIALS_ID = 'aws-jenkins-credentials' // Jenkins AWS creds ID
		LAMBDA_PREFIX = 'invoxa'                // Fallback prefix if TF outputs are unavailable
		TF_DIR = 'infra/shared-api'             // Terraform directory
		DOCKER_BUILD_PLATFORM = 'linux/amd64'   // Ensure linux/amd64 images compatible with Lambda

		// ECR repositories without tags (set these in Jenkins or edit here)
		AUTH_REPO = '857736875915.dkr.ecr.eu-west-1.amazonaws.com/invoxa-dev-auth'
		CLIENT_REPO = '857736875915.dkr.ecr.eu-west-1.amazonaws.com/invoxa-dev-client'
		INVOICE_REPO = '857736875915.dkr.ecr.eu-west-1.amazonaws.com/invoxa-dev-invoice'
		PAYMENT_REPO = '857736875915.dkr.ecr.eu-west-1.amazonaws.com/invoxa-dev-payment'
		INSIGHTS_REPO = '857736875915.dkr.ecr.eu-west-1.amazonaws.com/invoxa-dev-insights'
	}

	stages {
		stage('Resolve AWS Account') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					sh 'aws --version || true'
					script {
						env.AWS_ACCOUNT_ID = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
					}
					echo "Using AWS Account: ${env.AWS_ACCOUNT_ID} in ${env.AWS_REGION}"
				}
			}
		}



			stage('Determine Release Version') {
			steps {
				script {
						// Simple, deterministic dev tag: v0.0.<BUILD_NUMBER>
						env.IMAGE_TAG = "v0.0.${env.BUILD_NUMBER}"
					currentBuild.displayName = "#${env.BUILD_NUMBER} ${env.ENVIRONMENT} ${env.IMAGE_TAG}"
					echo "Release version: ${env.IMAGE_TAG}"
				}
			}
		}

			stage('Terraform Init') {
				steps {
					dir(env.TF_DIR) {
						withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
								sh label: 'Terraform init', script: '''
									set -eu
									terraform --version
									terraform init -input=false -var-file="terraform.tfvars"
									terraform workspace select dev || terraform workspace new dev
								'''
							}
						}
					}
				}
			}

			stage('Terraform Plan') {
				steps {
					dir(env.TF_DIR) {
						withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
								sh label: 'Terraform plan', script: 'terraform plan -input=false -var-file="terraform.tfvars" -out=tfplan'
							}
						}
					}
				}
			}

			stage('Terraform Apply (manual)') {
				steps {
					dir(env.TF_DIR) {
						input message: 'Approve Terraform apply to DEV?', ok: 'Apply'
						withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
								sh label: 'Terraform apply', script: 'terraform apply -input=false -var-file="terraform.tfvars" -auto-approve tfplan'
							}
						}
					}
				}
			}

			stage('Terraform Destroy (manual)') {
				steps {
					dir(env.TF_DIR) {
						script {
							def proceed = false
							try {
								timeout(time: 30, unit: 'SECONDS') {
									input message: 'Destroy DEV infra? This is destructive.', ok: 'Destroy'
								}
								proceed = true
							} catch (err) {
								echo 'Destroy skipped (no approval).'
							}
							if (proceed) {
								withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
									withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
										sh label: 'Terraform destroy', script: 'terraform destroy -input=false -var-file="terraform.tfvars" -auto-approve'
									}
								}
							}
						}
					}
				}
			}

		stage('Login to ECR') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						sh label: 'ECR Login', script: '''
							set -e
							aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
						'''
					}
				}
			}
		}

			stage('Build Images') {
			steps {
				script {
						def imageRepos = [
							auth: env.AUTH_REPO,
							client: env.CLIENT_REPO,
							invoice: env.INVOICE_REPO,
							payment: env.PAYMENT_REPO,
							insights: env.INSIGHTS_REPO
						].findAll { it.value?.trim() }
						if (!imageRepos) { error 'No ECR repos configured in environment variables.' }
						imageRepos.each { svc, repo ->
							def ctx1 = "microservices/${svc}-service/Dockerfile"
							def ctx2 = "microservices/${svc}/Dockerfile"
							def buildCtx = fileExists(ctx1) ? "microservices/${svc}-service" : (fileExists(ctx2) ? "microservices/${svc}" : null)
							if (!buildCtx) {
								echo "Skipping ${svc}: no Dockerfile context found"
								return
							}
							echo "[BUILD] ${svc} from ${buildCtx} -> ${repo}:${env.IMAGE_TAG}"
							sh label: "Build & push ${svc}", script: 
								'set -eu\n' +
								'URI="${repo}"\n' +
								'docker build --platform ${DOCKER_BUILD_PLATFORM} -t "$URI:${IMAGE_TAG}" -t "$URI:latest" "$buildCtx"\n'
						}
				}
			}
		}

		stage('Push Images') {
			steps {
				script {
					def imageRepos = [
						auth: env.AUTH_REPO,
						client: env.CLIENT_REPO,
						invoice: env.INVOICE_REPO,
						payment: env.PAYMENT_REPO,
						insights: env.INSIGHTS_REPO
					].findAll { it.value?.trim() }
					imageRepos.each { svc, repo ->
						echo "[PUSH] ${svc} -> ${repo}:${env.IMAGE_TAG} and latest"
						sh label: "Ensure & push ${svc}", script: 
							'set -eu\n' +
							'URI="${repo}"\n' +
							'REPO_NAME="$(basename \"$URI\")"\n' +
							'aws ecr describe-repositories --repository-names "$REPO_NAME" >/dev/null 2>&1 || aws ecr create-repository --repository-names "$REPO_NAME" >/dev/null\n' +
							'docker push "$URI:${IMAGE_TAG}"\n' +
							'docker push "$URI:latest"\n'
					}
				}
			}
		}

			stage('Deploy to Lambda') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						script {
								def imageRepos = [
									auth: env.AUTH_REPO,
									client: env.CLIENT_REPO,
									invoice: env.INVOICE_REPO,
									payment: env.PAYMENT_REPO,
									insights: env.INSIGHTS_REPO
								].findAll { it.value?.trim() }
								def targets = imageRepos.keySet().toList()
								targets.each { svc ->
									def repo = imageRepos[svc]
									if (!repo) { echo "No repo for ${svc}; skipping"; return }
									def imageUri = "${repo}:${env.IMAGE_TAG}"
								def fnName = "${env.LAMBDA_PREFIX}-${svc}-${env.ENVIRONMENT}"
									echo "Updating ${fnName} -> ${imageUri}"
									sh label: "Lambda update ${svc}", script: 
										'set -eu\n' +
										'aws lambda update-function-code --function-name "${fnName}" --image-uri "${imageUri}" > /dev/null\n' +
										'aws lambda wait function-updated --function-name "${fnName}"\n'
								}
						}
					}
				}
			}
		}
	}

	post {
		success {
			echo "${env.ENVIRONMENT} deploy complete: ${env.IMAGE_TAG}"
		}
		failure {
			echo 'Pipeline failed. Check logs above.'
		}
		always {
			script {
				echo "Artifacts: version=${env.IMAGE_TAG}, account=${env.AWS_ACCOUNT_ID}, region=${env.AWS_REGION}"
			}
		}
	}
}

