pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Select Terraform action to perform'
        )
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Auto-approve Terraform apply (use with caution)'
        )
        booleanParam(
            name: 'DEPLOY_CONTAINERS',
            defaultValue: true,
            description: 'Build and deploy container images to ECS'
        )
        string(
            name: 'DEPLOYMENT_TICKET',
            defaultValue: '',
            description: 'Deployment ticket number (required for production deployments)'
        )
    }
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '857736875915'  // Add your AWS account ID
        ENVIRONMENT = 'dev'
        TF_VAR_prefix = 'INX-DEV-USNV-'
        ECR_REPOSITORY_BASE = '857736875915.dkr.ecr.us-east-1.amazonaws.com/inx-INX-DEV-USNV--app'
        ECS_CLUSTER = 'INX-DEV-USNV-CLUSTER01'
        
        // Terraform backend configuration
        TF_STATE_BUCKET = 'inx-dev-terraform-state-9015480'
        TF_STATE_KEY = 'terraform.tfstate'
        TF_LOCK_TABLE = 'inx-dev-tf-locks'
        
        // AWS Role for DEV environment
        AWS_ROLE_ARN = 'arn:aws:iam::857736875915:role/RINX_DEVAWS_JENKINS_ADM'
    }
    
    stages {
        stage('🔍 Environment Validation') {
            steps {
                script {
                    echo "🚀 Starting INVOXA Infrastructure Deployment - DEV Environment"
                    echo "Branch: ${env.BRANCH_NAME}"
                    echo "Environment: ${env.ENVIRONMENT}"
                    echo "Action: ${params.ACTION}"
                    
                    if (env.BRANCH_NAME != 'cicd') {
                        error "❌ DEV pipeline should only run on 'cicd' branch. Current branch: ${env.BRANCH_NAME}"
                    }
                }
            }
        }
        
        stage('🔐 AWS Authentication') {
            steps {
                script {
                    echo "🔐 Assuming AWS Role for DEV environment..."
                    
                    withCredentials([aws(credentialsId: 'aws-jenkins-credentials', region: env.AWS_DEFAULT_REGION)]) {
                        def assumeRoleResult = sh(
                            script: """
                                aws sts assume-role \
                                    --role-arn ${env.AWS_ROLE_ARN} \
                                    --role-session-name jenkins-dev-session-\${BUILD_NUMBER} \
                                    --duration-seconds 3600 \
                                    --output json
                            """,
                            returnStdout: true
                        ).trim()
                        
                        def credentials = readJSON text: assumeRoleResult
                        
                        env.AWS_ACCESS_KEY_ID = credentials.Credentials.AccessKeyId
                        env.AWS_SECRET_ACCESS_KEY = credentials.Credentials.SecretAccessKey
                        env.AWS_SESSION_TOKEN = credentials.Credentials.SessionToken
                        
                        echo "✅ AWS credentials configured successfully"
                    }
                }
            }
        }
        
        stage('📋 Infrastructure Analysis') {
            steps {
                dir('terraform') {
                    script {
                        echo "📋 Analyzing Terraform configuration..."
                        
                        // Initialize Terraform
                        sh """
                            terraform init \
                                -backend-config="bucket=${env.TF_STATE_BUCKET}" \
                                -backend-config="key=${env.TF_STATE_KEY}" \
                                -backend-config="region=${env.AWS_DEFAULT_REGION}" \
                                -backend-config="dynamodb_table=${env.TF_LOCK_TABLE}" \
                                -reconfigure
                        """
                        
                        // Generate plan
                        def planOutput = sh(
                            script: 'terraform plan -var-file=dev.tfvars -detailed-exitcode -no-color',
                            returnStatus: true
                        )
                        
                        env.PLAN_EXIT_CODE = planOutput.toString()
                        
                        if (planOutput == 0) {
                            echo "✅ No infrastructure changes detected"
                            env.HAS_CHANGES = 'false'
                        } else if (planOutput == 2) {
                            echo "📊 Infrastructure changes detected - generating detailed plan..."
                            sh 'terraform plan -var-file=dev.tfvars -out=tfplan-dev'
                            
                            // Show what will change
                            def planShow = sh(
                                script: 'terraform show -no-color tfplan-dev',
                                returnStdout: true
                            )
                            
                            echo "🔄 PLANNED CHANGES:"
                            echo planShow
                            env.HAS_CHANGES = 'true'
                        } else {
                            error "❌ Terraform plan failed with exit code: ${planOutput}"
                        }
                    }
                }
            }
        }
        
        stage('🏗️ Infrastructure Deployment') {
            when {
                anyOf {
                    expression { params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
                    expression { params.ACTION == 'destroy' }
                }
            }
            steps {
                dir('terraform') {
                    script {
                        if (params.ACTION == 'apply') {
                            echo "🏗️ Deploying infrastructure changes..."
                            
                            if (params.AUTO_APPROVE) {
                                sh 'terraform apply -auto-approve tfplan-dev'
                            } else {
                                timeout(time: 10, unit: 'MINUTES') {
                                    input message: 'Approve infrastructure deployment?', ok: 'Deploy'
                                }
                                sh 'terraform apply -auto-approve tfplan-dev'
                            }
                            
                            echo "✅ Infrastructure deployment completed successfully!"
                            
                            // Store outputs for later stages
                            def outputs = sh(
                                script: 'terraform output -json',
                                returnStdout: true
                            )
                            writeFile file: 'terraform-outputs.json', text: outputs
                            archiveArtifacts artifacts: 'terraform-outputs.json'
                            
                        } else if (params.ACTION == 'destroy') {
                            echo "🗑️ Destroying infrastructure..."
                            timeout(time: 5, unit: 'MINUTES') {
                                input message: 'Are you sure you want to DESTROY the infrastructure?', ok: 'Destroy'
                            }
                            sh 'terraform destroy -var-file=dev.tfvars -auto-approve'
                        }
                    }
                }
            }
        }
        
        stage('🐳 Container Build & Push') {
            when {
                expression { params.DEPLOY_CONTAINERS && (params.ACTION == 'apply' || params.ACTION == 'plan') }
            }
            parallel {
                stage('Auth Service') {
                    steps {
                        script {
                            buildAndPushImage('auth-service', 'microservices/auth-service')
                        }
                    }
                }
                stage('Client Service') {
                    steps {
                        script {
                            buildAndPushImage('client-service', 'microservices/client-service')
                        }
                    }
                }
                stage('Invoice Service') {
                    steps {
                        script {
                            buildAndPushImage('invoice-service', 'microservices/invoice-service')
                        }
                    }
                }
                stage('Notification Service') {
                    steps {
                        script {
                            buildAndPushImage('notification-service', 'microservices/notification-service')
                        }
                    }
                }
                stage('Payment Service') {
                    steps {
                        script {
                            buildAndPushImage('payment-service', 'microservices/payment-service')
                        }
                    }
                }
            }
        }
        
        stage('🚀 ECS Service Deployment') {
            when {
                expression { params.DEPLOY_CONTAINERS && params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
            }
            steps {
                script {
                    echo "🚀 Deploying services to ECS Fargate..."
                    
                    def services = ['auth-service', 'client-service', 'invoice-service', 'notification-service', 'payment-service']
                    
                    services.each { service ->
                        deployECSService(service)
                    }
                }
            }
        }
        
        stage('✅ Deployment Verification') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                script {
                    if (env.HAS_CHANGES == 'false') {
                        echo """
                        ✅ DEPLOYMENT STATUS: NO CHANGES REQUIRED
                        
                        📊 Infrastructure State: Up to date
                        🏗️ Resources: All resources match desired configuration
                        📅 Last Updated: Current state is already aligned with Terraform configuration
                        
                        💡 Summary: No infrastructure changes were detected. Your DEV environment is running the latest configuration.
                        """
                    } else {
                        echo """
                        ✅ DEPLOYMENT STATUS: SUCCESSFULLY COMPLETED
                        
                        🏗️ Infrastructure: Updated with latest changes
                        🐳 Containers: Built and pushed to ECR
                        🚀 Services: Deployed to ECS Fargate
                        📅 Deployment Time: ${new Date()}
                        🎫 Ticket: ${params.DEPLOYMENT_TICKET ?: 'N/A'}
                        
                        💡 Summary: All components have been successfully deployed to the DEV environment.
                        """
                        
                        // Get ALB DNS name for verification
                        dir('terraform') {
                            def albDns = sh(
                                script: 'terraform output -raw alb_dns_name 2>/dev/null || echo "Not available"',
                                returnStdout: true
                            ).trim()
                            
                            if (albDns && albDns != "Not available") {
                                echo "🌐 Application URL: http://${albDns}"
                            }
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up
                sh 'rm -f terraform/tfplan-dev terraform/terraform-outputs.json'
                
                // Clear AWS credentials
                env.AWS_ACCESS_KEY_ID = ''
                env.AWS_SECRET_ACCESS_KEY = ''
                env.AWS_SESSION_TOKEN = ''
            }
        }
        success {
            echo '✅ Pipeline completed successfully!'
        }
        failure {
            echo '❌ Pipeline failed - check logs for details'
        }
        cleanup {
            cleanWs()
        }
    }
}

// Helper function to build and push Docker images
def buildAndPushImage(serviceName, contextPath) {
    echo "🐳 Building ${serviceName}..."
    
    try {
        // Get ECR login token
        sh '''
            aws ecr get-login-password --region ${AWS_DEFAULT_REGION} | \
            docker login --username AWS --password-stdin ${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_DEFAULT_REGION}.amazonaws.com
        '''
        
        // Build image
        def imageTag = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}"
        def fullImageName = "${env.ECR_REPOSITORY_BASE}:${serviceName}-${imageTag}"
        
        dir(contextPath) {
            sh """
                docker build -t ${serviceName}:latest .
                docker tag ${serviceName}:latest ${fullImageName}
                docker tag ${serviceName}:latest ${env.ECR_REPOSITORY_BASE}:${serviceName}-latest
            """
        }
        
        // Push to ECR
        sh """
            docker push ${fullImageName}
            docker push ${env.ECR_REPOSITORY_BASE}:${serviceName}-latest
        """
        
        echo "✅ ${serviceName} image pushed successfully"
        
    } catch (Exception e) {
        error "❌ Failed to build/push ${serviceName}: ${e.getMessage()}"
    }
}

// Helper function to deploy ECS services
def deployECSService(serviceName) {
    echo "🚀 Deploying ${serviceName} to ECS..."
    
    try {
        // Get network configuration from Terraform outputs  
        def terraformOutputs = readJSON file: 'terraform/terraform-outputs-dev.json'
        def privateSubnets = terraformOutputs.private_subnet_ids.value.join(',')
        def securityGroupId = terraformOutputs.ecs_security_group_id.value
        
        // Check if service exists
        def serviceExists = sh(
            script: """
                aws ecs describe-services \
                    --cluster ${env.ECS_CLUSTER} \
                    --services ${env.TF_VAR_prefix}${serviceName} \
                    --region ${env.AWS_DEFAULT_REGION} \
                    --query 'services[0].status' \
                    --output text 2>/dev/null || echo 'NONE'
            """,
            returnStdout: true
        ).trim()
        
        if (serviceExists == 'NONE' || serviceExists == 'INACTIVE') {
            echo "Creating new ECS service for ${serviceName}..."
            // Create service logic here
            sh """
                aws ecs create-service \
                    --cluster ${env.ECS_CLUSTER} \
                    --service-name ${env.TF_VAR_prefix}${serviceName} \
                    --task-definition ${env.TF_VAR_prefix}${serviceName} \
                    --desired-count 1 \
                    --launch-type FARGATE \
                    --network-configuration 'awsvpcConfiguration={subnets=[${privateSubnets}],securityGroups=[${securityGroupId}],assignPublicIp=DISABLED}' \
                    --region ${env.AWS_DEFAULT_REGION}
            """
        } else {
            echo "Updating existing ECS service for ${serviceName}..."
            sh """
                aws ecs update-service \
                    --cluster ${env.ECS_CLUSTER} \
                    --service ${env.TF_VAR_prefix}${serviceName} \
                    --task-definition ${env.TF_VAR_prefix}${serviceName} \
                    --region ${env.AWS_DEFAULT_REGION}
            """
        }
        
        echo "✅ ${serviceName} deployment initiated"
        
    } catch (Exception e) {
        error "❌ Failed to deploy ${serviceName} to ECS: ${e.getMessage()}"
    }
}
