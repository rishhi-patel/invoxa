pipeline {
	agent any

	options {
		timestamps()
		disableConcurrentBuilds()
	}

	environment {
		PROJECT = 'invoxa'
        ENVIRONMENT = 'dev'
		AWS_REGION = 'eu-west-1'
		AWS_CREDENTIALS_ID = 'aws-jenkins-credentials' // Jenkins AWS creds ID
		LAMBDA_PREFIX = 'invoxa'                // Fallback prefix if TF outputs are unavailable
		TF_DIR = 'infra/shared-api'             // Terraform directory
		DOCKER_BUILD_PLATFORM = 'linux/amd64'   // Ensure linux/amd64 images compatible with Lambda

	}

	stages {
		stage('Resolve AWS Account') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					sh 'aws --version || true'
					script {
						env.AWS_ACCOUNT_ID = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
					}
					echo "Using AWS Account: ${env.AWS_ACCOUNT_ID} in ${env.AWS_REGION}"
				}
			}
		}

		stage('Resolve ECR repos from SSM') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						script {
							def fetchRepo = { svc ->
								def paramName = "/${env.ENVIRONMENT}/image_uris/${svc}"
								def status = sh(returnStatus: true, label: "Check ${svc} repo param", script: "aws ssm get-parameter --name '${paramName}' --query 'Parameter.Value' --output text >/dev/null 2>&1")
								if (status == 0) {
									def value = sh(returnStdout: true, label: "Get ${svc} repo uri", script: "aws ssm get-parameter --name '${paramName}' --query 'Parameter.Value' --output text").trim()
									return value.contains(':') ? value.split(':')[0] : value
								} else {
									def fallback = "${env.AWS_ACCOUNT_ID}.dkr.ecr.${env.AWS_REGION}.amazonaws.com/${env.PROJECT}-${env.ENVIRONMENT}-${svc}"
									echo "[WARN] SSM parameter not found: ${paramName}. Using fallback: ${fallback}"
									return fallback
								}
							}
							env.AUTH_REPO     = fetchRepo('auth')
							env.CLIENT_REPO   = fetchRepo('client')
							env.INVOICE_REPO  = fetchRepo('invoice')
							env.PAYMENT_REPO  = fetchRepo('payment')
							env.INSIGHTS_REPO = fetchRepo('insights')
							echo "Resolved ECR repos: AUTH=${env.AUTH_REPO}, CLIENT=${env.CLIENT_REPO}, INVOICE=${env.INVOICE_REPO}, PAYMENT=${env.PAYMENT_REPO}, INSIGHTS=${env.INSIGHTS_REPO}"
						}
					}
				}
			}
		}



			stage('Determine Release Version') {
			steps {
				script {
						// Simple, deterministic dev tag: v0.0.<BUILD_NUMBER>
						env.IMAGE_TAG = "v0.0.${env.BUILD_NUMBER}"
					currentBuild.displayName = "#${env.BUILD_NUMBER} ${env.ENVIRONMENT} ${env.IMAGE_TAG}"
					echo "Release version: ${env.IMAGE_TAG}"
				}
			}
		}

			stage('Terraform Init') {
				steps {
					dir(env.TF_DIR) {
						withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}"]) {
								sh label: 'Terraform init', script: '''
									set -eu
									terraform --version
									terraform init -input=false
									terraform workspace select dev || terraform workspace new dev
								'''
							}
						}
					}
				}
			}

			stage('Terraform Plan (infra only)') {
				steps {
					dir(env.TF_DIR) {
						withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}"]) {
								sh label: 'Terraform plan', script: 'terraform plan -input=false -var="create_lambdas=false" -out=tfplan'
							}
						}
					}
				}
			}

			stage('Terraform Apply (infra only)') {
				steps {
					dir(env.TF_DIR) {
						withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}"]) {
								sh label: 'Terraform apply', script: 'terraform apply -input=false -auto-approve tfplan'
							}
						}
					}
				}
			}

		stage('Login to ECR') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						sh label: 'ECR Login', script: '''
							set -e
							aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
						'''
					}
				}
			}
		}

			stage('Build Images') {
			steps {
				script {
					sh label: 'Load ECR env', script: 'test -f .ecr_env && . ./.ecr_env || true'
						def imageRepos = [
							auth: env.AUTH_REPO,
							client: env.CLIENT_REPO,
							invoice: env.INVOICE_REPO,
							payment: env.PAYMENT_REPO,
							insights: env.INSIGHTS_REPO
						].findAll { it.value?.trim() }
						if (!imageRepos) { error 'No ECR repos configured in environment variables.' }
						imageRepos.each { svc, repo ->
							def ctx1 = "microservices/${svc}-service/Dockerfile"
							def ctx2 = "microservices/${svc}/Dockerfile"
							def buildCtx = fileExists(ctx1) ? "microservices/${svc}-service" : (fileExists(ctx2) ? "microservices/${svc}" : null)
							if (!buildCtx) {
								echo "Skipping ${svc}: no Dockerfile context found"
								return
							}
							echo "[BUILD] ${svc} from ${buildCtx} -> ${repo}:${env.IMAGE_TAG}"
							sh label: "Build ${svc}", script: """
								set -eu
								URI='${repo}'
								BUILD_CTX='${buildCtx}'
								docker build --platform ${DOCKER_BUILD_PLATFORM} -t "\$URI:${IMAGE_TAG}" -t "\$URI:latest" "\$BUILD_CTX"
							"""
						}
				}
			}
		}

	stage('Push Images') {
			steps {
				script {
					def imageRepos = [
						auth: env.AUTH_REPO,
						client: env.CLIENT_REPO,
						invoice: env.INVOICE_REPO,
						payment: env.PAYMENT_REPO,
						insights: env.INSIGHTS_REPO
					].findAll { it.value?.trim() }
					imageRepos.each { svc, repo ->
						echo "[PUSH] ${svc} -> ${repo}:${env.IMAGE_TAG} and latest"
						sh label: "Ensure & push ${svc}", script: """
							set -eu
							URI='${repo}'
							REPO_NAME="\$(basename \"\$URI\")"
							aws ecr describe-repositories --repository-names "\$REPO_NAME" >/dev/null 2>&1 || aws ecr create-repository --repository-names "\$REPO_NAME" >/dev/null
							docker push "\$URI:${IMAGE_TAG}"
							docker push "\$URI:latest"
						"""
					}
				}
			}
		}

			stage('Terraform Plan (lambdas)') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}"]) {
								sh label: 'Terraform plan (lambdas)', script: 'terraform plan -input=false -var="create_lambdas=true" -out=tfplan'
						}
					}
				}
			}
		}

			stage('Terraform Apply (lambdas)') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
							withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}"]) {
								sh label: 'Terraform apply (lambdas)', script: 'terraform apply -input=false -auto-approve tfplan'
						}
					}
				}
			}
		}

		// Removed ad-hoc Deploy to Lambda stage; handled by Terraform
	}

	post {
		success {
			echo "${env.ENVIRONMENT} deploy complete: ${env.IMAGE_TAG}"
		}
		failure {
			echo 'Pipeline failed. Check logs above.'
		}
		always {
			script {
				echo "Artifacts: version=${env.IMAGE_TAG}, account=${env.AWS_ACCOUNT_ID}, region=${env.AWS_REGION}"
			}
		}
	}
}

