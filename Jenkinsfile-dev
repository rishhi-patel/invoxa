pipeline {
    agent any
    
    parameters {
        choice(
            name: 'ACTION',
            choices: ['plan', 'apply', 'destroy'],
            description: 'Select Terraform action to perform'
        )
        booleanParam(
            name: 'AUTO_APPROVE',
            defaultValue: false,
            description: 'Auto-approve Terraform apply (use with caution)'
        )
        booleanParam(
            name: 'DEPLOY_CONTAINERS',
            defaultValue: false,
            description: 'Build and deploy container images to ECS (disabled due to Docker permissions)'
        )
        string(
            name: 'DEPLOYMENT_TICKET',
            defaultValue: '',
            description: 'Deployment ticket number (required for production deployments)'
        )
    }
    
    environment {
        AWS_DEFAULT_REGION = 'us-east-1'
        AWS_ACCOUNT_ID = '857736875915'
        ENVIRONMENT = 'dev'
        TF_VAR_prefix = 'INX-DEV-USNV-'
        ECR_REPOSITORY_BASE = 'public.ecr.aws/i5k8d9h4'
        ECS_CLUSTER = 'INX-DEV-USNV-CLUSTER01'
        ECR_PREFIX = 'inxdevusnv' // Lowercase prefix for ECR repository names
        
        // Terraform backend configuration
        TF_STATE_BUCKET = 'inx-dev-terraform-state-config'
        TF_STATE_KEY = 'terraform.tfstate'
        TF_LOCK_TABLE = 'inx-dev-tf-locks'
        
        // AWS Role for DEV environment
        AWS_ROLE_ARN = 'arn:aws:iam::857736875915:role/RINX_DEVAWS_JENKINS_ADM'
    }
    
    stages {
        stage('Environment Validation') {
            steps {
                script {
                    echo "Starting INVOXA Infrastructure Deployment - DEV Environment"
                    
                    // Get branch name from Git
                    def branchName = env.BRANCH_NAME ?: sh(
                        script: 'git rev-parse --abbrev-ref HEAD',
                        returnStdout: true
                    ).trim()
                    
                    echo "Branch: ${branchName}"
                    echo "Environment: ${env.ENVIRONMENT}"
                    echo "Action: ${params.ACTION}"
                    echo "Git Commit: ${env.GIT_COMMIT ?: 'Not available'}"
                    
                    // Store branch name for other stages
                    env.CURRENT_BRANCH = branchName
                    
                    // Branch validation (relaxed for initial testing)
                    if (branchName != 'cicd') {
                        echo "WARNING: DEV pipeline is recommended to run on 'cicd' branch. Current branch: ${branchName}"
                        echo "Continuing deployment for testing purposes..."
                    } else {
                        echo "Running on correct branch: ${branchName}"
                    }
                }
            }
        }
        
        stage('AWS Authentication') {
            steps {
                script {
                    echo "Setting up AWS credentials using Jenkins AWS Plugin..."
                    
                    withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
                        // Test AWS connectivity
                        def callerIdentity = sh(
                            script: 'aws sts get-caller-identity --output json',
                            returnStdout: true
                        ).trim()
                        
                        def identity = readJSON text: callerIdentity
                        echo "AWS authenticated as: ${identity.Arn}"
                        echo "Account ID: ${identity.Account}"
                        
                        // Verify access to S3 bucket
                        sh "aws s3 ls s3://${env.TF_STATE_BUCKET}/ || echo 'Note: S3 bucket may not exist yet - will be created if needed'"
                    }
                }
            }
        }
        
        stage('Infrastructure Analysis') {
            steps {
                dir('terraform') {
                    script {
                        echo "Analyzing Terraform configuration..."
                        
                        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
                            // Initialize Terraform
                            sh """
                                terraform init \
                                    -backend-config="bucket=${env.TF_STATE_BUCKET}" \
                                    -backend-config="key=${env.TF_STATE_KEY}" \
                                    -backend-config="region=${env.AWS_DEFAULT_REGION}" \
                                    -backend-config="dynamodb_table=${env.TF_LOCK_TABLE}" \
                                    -reconfigure
                            """
                            
                            // Generate plan
                            def planOutput = sh(
                                script: 'terraform plan -var-file=dev.tfvars -detailed-exitcode -no-color',
                                returnStatus: true
                            )
                            
                            env.PLAN_EXIT_CODE = planOutput.toString()
                            
                            if (planOutput == 0) {
                                echo "No infrastructure changes detected"
                                env.HAS_CHANGES = 'false'
                            } else if (planOutput == 2) {
                                echo "Infrastructure changes detected - generating detailed plan..."
                                sh 'terraform plan -var-file=dev.tfvars -out=tfplan-dev'
                                
                                // Show what will change
                                def planShow = sh(
                                    script: 'terraform show -no-color tfplan-dev',
                                    returnStdout: true
                                )
                                
                                echo "PLANNED CHANGES:"
                                echo planShow
                                env.HAS_CHANGES = 'true'
                            } else {
                                error "Terraform plan failed with exit code: ${planOutput}"
                            }
                        }
                    }
                }
            }
        }
        
        stage('Infrastructure Deployment') {
            when {
                anyOf {
                    expression { params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
                    expression { params.ACTION == 'destroy' }
                }
            }
            steps {
                dir('terraform') {
                    script {
                        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
                            if (params.ACTION == 'apply') {
                                echo "Deploying infrastructure changes..."
                                
                                if (params.AUTO_APPROVE) {
                                    sh 'terraform apply -auto-approve tfplan-dev'
                                } else {
                                    timeout(time: 10, unit: 'MINUTES') {
                                        input message: 'Approve infrastructure deployment?', ok: 'Deploy'
                                    }
                                    sh 'terraform apply -auto-approve tfplan-dev'
                                }
                                
                                echo "Infrastructure deployment completed successfully!"
                                
                                // Store outputs for later stages
                                def outputs = sh(
                                    script: 'terraform output -json',
                                    returnStdout: true
                                )
                                writeFile file: 'terraform-outputs-dev.json', text: outputs
                                archiveArtifacts artifacts: 'terraform-outputs-dev.json'
                                
                            } else if (params.ACTION == 'destroy') {
                                echo "Destroying infrastructure..."
                                timeout(time: 5, unit: 'MINUTES') {
                                    input message: 'Are you sure you want to DESTROY the infrastructure?', ok: 'Destroy'
                                }
                                sh 'terraform destroy -var-file=dev.tfvars -auto-approve'
                            }
                        }
                    }
                }
            }
        }
        
        stage('Container Build & Push') {
            when {
                expression { params.DEPLOY_CONTAINERS && (params.ACTION == 'apply' || params.ACTION == 'plan') }
            }
            parallel {
                stage('Auth Service') {
                    steps {
                        script {
                            // Check Docker permissions before building
                            checkDockerPermissions()
                            buildAndPushImage('auth-service', 'microservices/auth-service')
                        }
                    }
                }
                stage('Client Service') {
                    steps {
                        script {
                            // Check Docker permissions before building
                            checkDockerPermissions()
                            buildAndPushImage('client-service', 'microservices/client-service')
                        }
                    }
                }
                stage('Invoice Service') {
                    steps {
                        script {
                            // Check Docker permissions before building
                            checkDockerPermissions()
                            buildAndPushImage('invoice-service', 'microservices/invoice-service')
                        }
                    }
                }
                stage('Notification Service') {
                    steps {
                        script {
                            // Check Docker permissions before building
                            checkDockerPermissions()
                            buildAndPushImage('notification-service', 'microservices/notification-service')
                        }
                    }
                }
                stage('Payment Service') {
                    steps {
                        script {
                            // Check Docker permissions before building
                            checkDockerPermissions()
                            buildAndPushImage('payment-service', 'microservices/payment-service')
                        }
                    }
                }
            }
        }
        
        stage('ECS Service Deployment') {
            when {
                expression { params.DEPLOY_CONTAINERS && params.ACTION == 'apply' && env.HAS_CHANGES == 'true' }
            }
            steps {
                script {
                    echo "Deploying services to ECS Fargate..."
                    
                    def services = ['auth-service', 'client-service', 'invoice-service', 'notification-service', 'payment-service']
                    
                    services.each { service ->
                        deployECSService(service)
                    }
                }
            }
        }
        
        stage('Deployment Verification') {
            when {
                expression { params.ACTION == 'apply' }
            }
            steps {
                script {
                    if (env.HAS_CHANGES == 'false') {
                        echo """
                        DEPLOYMENT STATUS: NO CHANGES REQUIRED
                        
                        Infrastructure State: Up to date
                        Resources: All resources match desired configuration
                        Last Updated: Current state is already aligned with Terraform configuration
                        
                        Summary: No infrastructure changes were detected. Your DEV environment is running the latest configuration.
                        """
                    } else {
                        echo """
                        DEPLOYMENT STATUS: SUCCESSFULLY COMPLETED
                        
                        Infrastructure: Updated with latest changes
                        Containers: Built and pushed to ECR
                        Services: Deployed to ECS Fargate
                        Deployment Time: ${new Date()}
                        Ticket: ${params.DEPLOYMENT_TICKET ?: 'N/A'}
                        
                        Summary: All components have been successfully deployed to the DEV environment.
                        """
                        
                        // Get ALB DNS name for verification
                        dir('terraform') {
                            def albDns = sh(
                                script: 'terraform output -raw alb_dns_name 2>/dev/null || echo "Not available"',
                                returnStdout: true
                            ).trim()
                            
                            if (albDns && albDns != "Not available") {
                                echo "Application URL: http://${albDns}"
                            }
                        }
                    }
                }
            }
        }
    }
    
    post {
        always {
            script {
                // Clean up
                sh 'rm -f terraform/tfplan-dev terraform/terraform-outputs-dev.json'
                
                // Clear AWS credentials
                env.AWS_ACCESS_KEY_ID = ''
                env.AWS_SECRET_ACCESS_KEY = ''
                env.AWS_SESSION_TOKEN = ''
            }
        }
        success {
            echo 'Pipeline completed successfully!'
        }
        failure {
            echo 'Pipeline failed - check logs for details'
        }
        cleanup {
            cleanWs()
        }
    }
}

// Helper function to check Docker permissions
def checkDockerPermissions() {
    try {
        sh 'docker --version'
        echo "Docker is available, checking permissions..."
        
        def dockerTest = sh(
            script: 'docker info >/dev/null 2>&1',
            returnStatus: true
        )
        
        if (dockerTest != 0) {
            echo "Docker permission issue detected. Attempting to fix..."
            sh '''
                sudo usermod -aG docker jenkins || echo "Cannot add user to docker group"
                sudo chmod 666 /var/run/docker.sock || echo "Cannot change socket permissions"
            '''
        } else {
            echo "Docker permissions are working correctly"
        }
    } catch (Exception e) {
        echo "Warning: Docker setup issue - ${e.getMessage()}"
        echo "Continuing with Docker commands..."
    }
}

// Helper function to build and push Docker images
def buildAndPushImage(serviceName, contextPath) {
    echo "Building ${serviceName}..."
    
    try {
        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
            // Check Docker permissions first
            def dockerTest = sh(
                script: 'docker info >/dev/null 2>&1',
                returnStatus: true
            )
            
            if (dockerTest != 0) {
                echo "WARNING: Docker permission issue detected for ${serviceName}"
                echo "Attempting to fix Docker socket permissions..."
                
                // Try to fix permissions (may require Jenkins user to be in docker group)
                sh '''
                    # Check if docker group exists and add jenkins user
                    getent group docker >/dev/null 2>&1 || sudo groupadd docker
                    sudo usermod -aG docker $USER || echo "Cannot add user to docker group"
                    # Fix socket permissions temporarily
                    sudo chmod 666 /var/run/docker.sock || echo "Cannot change socket permissions"
                    # Test again
                    docker info >/dev/null 2>&1 || echo "Docker still not accessible - manual intervention required"
                '''
            }
            
            // Get Public ECR login token (us-east-1 only)
            sh 'aws ecr-public get-login-password --region us-east-1 | docker login --username AWS --password-stdin public.ecr.aws'
            
            // Build image
            def imageTag = "${env.BUILD_NUMBER}-${env.GIT_COMMIT.take(7)}"
            def ecrRepoName = "${env.ECR_PREFIX}${serviceName}"
            def fullImageName = "${env.ECR_REPOSITORY_BASE}/${ecrRepoName}:${imageTag}"
            
            dir(contextPath) {
                sh """
                    docker build -t ${serviceName}:latest .
                    docker tag ${serviceName}:latest ${fullImageName}
                    docker tag ${serviceName}:latest ${env.ECR_REPOSITORY_BASE}/${ecrRepoName}:latest
                """
            }
            
            // Push to Public ECR
            sh """
                docker push ${fullImageName}
                docker push ${env.ECR_REPOSITORY_BASE}/${ecrRepoName}:latest
            """
            
            echo "${serviceName} image pushed successfully to Public ECR as ${ecrRepoName}"
        }
        
    } catch (Exception e) {
        echo "CONTAINER BUILD FAILED for ${serviceName}: ${e.getMessage()}"
        echo "This is likely a Docker permissions issue. Infrastructure deployment was successful."
        echo "Manual steps needed:"
        echo "1. Add Jenkins user to Docker group: sudo usermod -aG docker jenkins"
        echo "2. Restart Jenkins service: sudo systemctl restart jenkins"
        echo "3. Or fix Docker socket permissions: sudo chmod 666 /var/run/docker.sock"
        
        // Don't fail the entire pipeline for container build issues
        currentBuild.result = 'UNSTABLE'
        echo "Continuing pipeline execution despite container build failure..."
    }
}

// Helper function to deploy ECS services
def deployECSService(serviceName) {
    echo "Deploying ${serviceName} to ECS..."
    
    try {
        withCredentials([aws(credentialsId: 'aws-jenkins-credentials')]) {
            // Get network configuration from Terraform outputs  
            def terraformOutputs = readJSON file: 'terraform/terraform-outputs-dev.json'
            def privateSubnets = terraformOutputs.private_subnet_ids.value.join(',')
            def securityGroupId = terraformOutputs.ecs_security_group_id.value
            
            // Check if service exists
            def serviceExists = sh(
                script: """
                    aws ecs describe-services \
                        --cluster ${env.ECS_CLUSTER} \
                        --services ${env.TF_VAR_prefix}${serviceName} \
                        --region ${env.AWS_DEFAULT_REGION} \
                        --query 'services[0].status' \
                        --output text 2>/dev/null || echo 'NONE'
                """,
                returnStdout: true
            ).trim()
            
            if (serviceExists == 'NONE' || serviceExists == 'INACTIVE') {
                echo "Creating new ECS service for ${serviceName}..."
                sh """
                    aws ecs create-service \
                        --cluster ${env.ECS_CLUSTER} \
                        --service-name ${env.TF_VAR_prefix}${serviceName} \
                        --task-definition ${env.TF_VAR_prefix}${serviceName} \
                        --desired-count 1 \
                        --launch-type FARGATE \
                        --network-configuration 'awsvpcConfiguration={subnets=[${privateSubnets}],securityGroups=[${securityGroupId}],assignPublicIp=DISABLED}' \
                        --region ${env.AWS_DEFAULT_REGION}
                """
            } else {
                echo "Updating existing ECS service for ${serviceName}..."
                sh """
                    aws ecs update-service \
                        --cluster ${env.ECS_CLUSTER} \
                        --service ${env.TF_VAR_prefix}${serviceName} \
                        --task-definition ${env.TF_VAR_prefix}${serviceName} \
                        --region ${env.AWS_DEFAULT_REGION}
                """
            }
            
            echo "${serviceName} deployment initiated"
        }
        
    } catch (Exception e) {
        error "Failed to deploy ${serviceName} to ECS: ${e.getMessage()}"
    }
}
