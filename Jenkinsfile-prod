pipeline {
	agent any

	options {
		timestamps()
		disableConcurrentBuilds()
	}

	parameters {
		string(name: 'IMAGE_TAG', defaultValue: '', description: 'Existing ECR image tag to deploy (e.g., v1.2.3). Required')
	}

	environment {
		ENVIRONMENT = 'prod'
	AWS_REGION = 'us-east-1'
		AWS_CREDENTIALS_ID = 'aws-jenkins-credentials' // Jenkins AWS creds ID
		LAMBDA_PREFIX = 'invoxa'                // Fallback prefix if TF outputs are unavailable
		TF_DIR = 'infra/shared-api'             // Terraform directory
		DOCKER_BUILD_PLATFORM = 'linux/amd64'
	}

	stages {
		stage('Guard: main branch only') {
			when { not { branch 'main' } }
			steps { error 'Production deploys are restricted to main branch' }
		}

		stage('Resolve AWS Account') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					sh 'aws --version || true'
					script {
						env.AWS_ACCOUNT_ID = sh(returnStdout: true, script: 'aws sts get-caller-identity --query Account --output text').trim()
					}
					echo "Using AWS Account: ${env.AWS_ACCOUNT_ID} in ${env.AWS_REGION}"
				}
			}
		}
        
		stage('Resolve ECR repos from SSM') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						script {
							def fetchRepo = { svc ->
								def paramName = "/${env.ENVIRONMENT}/image_uris/${svc}"
								def value = sh(returnStdout: true, label: "Get ${svc} repo uri", script: "aws ssm get-parameter --name '${paramName}' --query 'Parameter.Value' --output text").trim()
								return value.contains(':') ? value.split(':')[0] : value
							}
							env.AUTH_REPO     = fetchRepo('auth')
							env.CLIENT_REPO   = fetchRepo('client')
							env.INVOICE_REPO  = fetchRepo('invoice')
							env.PAYMENT_REPO  = fetchRepo('payment')
							env.INSIGHTS_REPO = fetchRepo('insights')
							echo "Resolved ECR repos: AUTH=${env.AUTH_REPO}, CLIENT=${env.CLIENT_REPO}, INVOICE=${env.INVOICE_REPO}, PAYMENT=${env.PAYMENT_REPO}, INSIGHTS=${env.INSIGHTS_REPO}"
						}
					}
				}
			}
		}

			stage('Select Image Tag') {
				steps {
					script {
						if (!params.IMAGE_TAG?.trim()) {
							error 'IMAGE_TAG parameter is required for prod.'
						}
						env.IMAGE_TAG = params.IMAGE_TAG.trim()
						currentBuild.displayName = "#${env.BUILD_NUMBER} ${env.ENVIRONMENT} ${env.IMAGE_TAG}"
					}
				}
			}

		stage('Terraform Init') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
						withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}", "TF_VAR_manage_roles=false"]) {
							sh label: 'Terraform init', script: '''
								set -eu
								terraform --version
								terraform init -input=false
								terraform workspace select prod || terraform workspace new prod
							'''
						}
					}
				}
			}
		}

		stage('Terraform Plan (infra only)') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
						withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}", "TF_VAR_manage_roles=false"]) {
							sh label: 'Terraform plan', script: 'terraform plan -input=false -var="create_lambdas=false" -out=tfplan'
						}
					}
				}
			}
		}

		stage('Terraform Apply (infra only)') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
						withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}", "TF_VAR_manage_roles=false"]) {
							sh label: 'Terraform apply', script: 'terraform apply -input=false -auto-approve tfplan'
						}
					}
				}
			}
		}

        
		stage('Login to ECR') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						sh label: 'ECR Login', script: '''
							set -e
							aws ecr get-login-password --region "$AWS_DEFAULT_REGION" | docker login --username AWS --password-stdin "$AWS_ACCOUNT_ID.dkr.ecr.$AWS_DEFAULT_REGION.amazonaws.com"
						'''
					}
				}
			}
		}

		stage('Update SSM image_uris with tag') {
			steps {
				withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
					withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}"]) {
						script {
							def imageRepos = [
								auth: env.AUTH_REPO,
								client: env.CLIENT_REPO,
								invoice: env.INVOICE_REPO,
								payment: env.PAYMENT_REPO,
								insights: env.INSIGHTS_REPO
							].findAll { it.value?.trim() }
							imageRepos.each { svc, repo ->
								def paramName = "/${env.ENVIRONMENT}/image_uris/${svc}"
								def value = "${repo}:${env.IMAGE_TAG}"
								echo "Updating SSM ${paramName} -> ${value}"
								sh label: "SSM put-parameter ${svc}", script: """
									set -eu
									aws ssm put-parameter --name "${paramName}" --type String --value "${value}" --overwrite >/dev/null
								"""
							}
						}
					}
				}
			}
		}

		stage('Terraform Plan (lambdas)') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
						withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}", "TF_VAR_manage_roles=false"]) {
							sh label: 'Terraform plan (lambdas)', script: 'terraform plan -input=false -var="create_lambdas=true" -out=tfplan'
						}
					}
				}
			}
		}

		stage('Terraform Apply (lambdas)') {
			steps {
				dir(env.TF_DIR) {
					withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: env.AWS_CREDENTIALS_ID, accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
						withEnv(["AWS_DEFAULT_REGION=${env.AWS_REGION}", "TF_VAR_project=invoxa", "TF_VAR_env=${env.ENVIRONMENT}", "TF_VAR_region=${env.AWS_REGION}", "TF_VAR_manage_roles=false"]) {
							sh label: 'Terraform apply (lambdas)', script: 'terraform apply -input=false -auto-approve tfplan'
						}
					}
				}
			}
		}
	}

	post {
		success {
			echo "${env.ENVIRONMENT} deploy complete: ${env.IMAGE_TAG}"
		}
		failure {
			echo 'Pipeline failed. Check logs above.'
		}
	}
}

